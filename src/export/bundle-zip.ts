// =============================================================================
// System Bundle → ZIP Packager
// Downloads a SystemBundle as a ZIP file with the canonical directory layout:
//   system.json, canvas.json, agents/, mcp/, ecosystem.config.js, .env.example
// =============================================================================

import JSZip from 'jszip';
import { SystemBundle } from './types';
import { generatePm2Config } from './pm2-config-generator';
import { generateClaudeMd } from './claude-md-generator';
import { MCPServerConfig } from '@/types/core';
import { slugify } from '@/utils/exportHelpers';

/**
 * Package a SystemBundle into a ZIP blob and trigger a browser download.
 *
 * ZIP structure:
 *   system.json           - The SystemManifest
 *   canvas.json            - Sanitized canvas state (nodes + edges)
 *   agents/<slug>/CLAUDE.md - Per-agent CLAUDE.md files
 *   mcp/<name>.json        - Per-MCP-server config files
 *   ecosystem.config.js    - PM2 process config
 *   .env.example           - Required environment variables
 */
export async function downloadBundleAsZip(bundle: SystemBundle): Promise<void> {
  const zip = new JSZip();
  const systemContext = bundle.manifest.description || bundle.manifest.name;

  // 1. system.json — the manifest
  zip.file('system.json', JSON.stringify(bundle.manifest, null, 2));

  // 2. canvas.json — sanitized canvas state
  zip.file('canvas.json', JSON.stringify(bundle.canvasJson, null, 2));

  // 3. agents/<slug>/CLAUDE.md — one per agent
  for (const [agentSlug, agentConfig] of Object.entries(bundle.agentConfigs)) {
    const md = generateClaudeMd(agentConfig, systemContext);
    zip.file(`agents/${agentSlug}/CLAUDE.md`, md);
  }

  // 4. mcp/<name>.json — one per MCP server
  for (const mcpConfig of bundle.mcpConfigs) {
    const name = slugify(mcpConfig.name);
    const content = formatMcpConfig(mcpConfig);
    zip.file(`mcp/${name}.json`, content);
  }

  // 5. ecosystem.config.js — PM2 config
  const pm2Config = generatePm2Config(bundle);
  const ecosystemJs =
    `// PM2 Ecosystem Configuration\n` +
    `// Generated by Visual Agent Builder\n` +
    `module.exports = ${JSON.stringify(pm2Config, null, 2)};\n`;
  zip.file('ecosystem.config.js', ecosystemJs);

  // 6. .env.example — required environment variables
  const envLines: string[] = [
    `# Environment variables for: ${bundle.manifest.name}`,
    `# Generated by Visual Agent Builder`,
    '',
  ];
  for (const [key, comment] of Object.entries(bundle.envExample)) {
    envLines.push(comment);
    envLines.push(`${key}=`);
    envLines.push('');
  }
  zip.file('.env.example', envLines.join('\n'));

  // Generate and download
  const blob = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 9 },
  });

  const filename = `${bundle.manifest.slug}-bundle.zip`;
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Format a single MCP server config as a JSON file
 * matching the .claude/mcp.json entry shape.
 */
function formatMcpConfig(config: MCPServerConfig): string {
  const entry: Record<string, unknown> = {
    command: config.command || 'npx',
    args: config.args || [],
  };

  if (config.env && Object.keys(config.env).length > 0) {
    entry.env = config.env;
  }

  if (config.auth) {
    entry.auth = config.auth;
  }

  if (config.tools && config.tools.length > 0) {
    entry.tools = config.tools;
  }

  if (config.timeout) {
    entry.timeout = config.timeout;
  }

  return JSON.stringify({ [config.name]: entry }, null, 2);
}
